# JS_CH5
5 - 1 : 외부 함수의 변수를 참조하는 내부 함수(1)
  outer함수의 내부함수인 inner함수에서 outerEnvironmentReference에 있는 a값을 참조하고 그 값을 1증가시키도록 하고 있으므로 클로저이다. 클로저란 어떤 함수 A에서 선언한 변수를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수가 사라지지 않는 현상을 말한다.

5 - 2 : 외부 함수의 변수를 참조하는 내부 함수(2)
  동작 방식은 5 - 1의 코드와 같고 outer함수의 반환이 inner함수의 실행결과로 바뀌었다. 이렇게 하면 outer함수가 종료된 시점에는 a 변수를 참조하는 대상이 없어지므로 GC대상이 되어 없어진다.

5 - 3 : 외부 함수의 변수를 참조하는 내부 함수(3)
  동작 방식은 5 - 2와 비슷하다. 여기서는 outer함수의 반환을 inner함수 자체로 하였다. 그리고 8번째 줄에 outer2를 outer함수로 선언하였다. 이렇게 되면 GC컬렉터가 a를 제거시키지 않는데 그 이유는 어떤 값을 참조하는 변수가 하나라도 있으면 수집 대상에 포함시키지 않기 때문이다.

5 - 4 - 1 : return 없이도 클로저가 발생하는 다양한 경우(1)
  익명함수의 변수 a를 내부함수인 inner가 참조하여 a가 10이상이 되면 clearInterval함수가 동작되도록 하고있다. return이 없어도 클로저 현상이 발생하는 것을 확인할 수 있다.

5 - 4 - 2 : return 없이도 클로저가 발생하는 다양한 경우(2)
  5 - 4 - 1과 마찬가지로 익명함수의 counter변수를 button.addEventListener가 참조하고 있으므로 return없이도 클로저현상이 발생하는 것을 확인할 수 있다.

5 - 5 - 1 : 클로저의 메모리 관리(1)
  코드는 예제 5 - 3과 같고, outer의 참조 카운트가 0이 되도록 하기위해 마지막줄에 outer에 null을 가리키도록하였다. 따라서 GC대상이어 없어진다.

5 - 5 - 2 : 클로저의 메모리 관리(2)
  코드는 예제 5 - 4 - 1과 같고 내부함수인 inner함수의 if문에 clearInterval함수가 실행되고 다음으로 inner함수에 null을 가리키도록 하여 식별자의 함수 참조를 끊게하여 GC대상이 되도록 하였다.
 
5 - 5 - 3 : 클로저의 메모리 관리(3)
  코드는 5 - 4 - 2와 같고 button.removeEventListener함수에 clickHandler함수가 식별자의 참조를 끊게 하기위해 null을 가리키도록하여 GC대상이 되도록 하였다.

5 - 6 : 콜백 함수와 클로저(1)
  fruits.forEach $li.addEventListener에 익명함수로 콜백 함수를 입력하였고, 클로저는 앞선 함수 내부 $li.addEventListener함수가 outerEnvironmentReference에 있는 fruit이다. 

5 - 7 : 콜백 함수와 클로저(2)
  코드는 5 - 7에서 $li.addEventListener에 있던 alert함수를 fruit.forEach함수 외부로 다시 alertFruit으로 익명함수로 선언하였다. 동작 방식은 같지만, li를 클릭하게 되면 object MouseEvent값이 출력이 된다. 이는 콜백 함수의 인자에 대한 제어권을 addEventListener가 가진 상태이며, addEventListener는 콜백 함수를 호출할 때 첫 번째 인자에 이벤트 객체를 주입하기 때문이다.  

5 - 8 : 콜백 함수와 클로저(3)
  5 - 7의 문제점을 bind메서드로 해결 할 수 있다. 코드는 5 - 7에 $li.addEventListener의 인자로 alertFruit.bind를 넘겨주면 이벤트 객체가 인자로 넘어오는 순서가 바뀌어 다시 대상 과일명이 출력되는 것을 확인할 수 있다. 하지만 this가 달라진다.

5 - 9 : 콜백 함수와 클로저(4)
  코드는 5 - 8에서 alertFruitBuilder에 익명함수를 넣어 실행되면 return으로 익명함수로 alert가 실행되도록 하였다. 12번째 줄에서 alertFruitBuilder함수를 실행하면서 fruit값을 인자로 전달하였고, 이 함수의 실행 결과가 다시 함수가 되어 이렇게 반환된 함수를 리스너에 콜백 함수로써 전달할 것이다. 이 후 클릭 이벤트가 발생하면 이 함수의 실행 컨텍스트가 열리면서 인자로 넘어온 fruit을 참조할 수 있다.

5 - 10 : 간단한 자동차 객체
  변수 car에 직접적으로 객체가 fuel, power, move 멤버를 갖도록 선언하였다. 이로써 간단한 자동차 객체를 만들었다.

5 - 11 : 클로저로 변수를 보호한 자동차 객체(1)
  코드를 5 - 10과 달리 위 코드는 createCar라는 함수를 실행하게 함으로써 객체를 생성하도록 하였다. fuel, power변수는 비공개 멤버로 지정해 외부에서의 접근을 제한했고, moved변수는 getter만을 부여함으로써 읽기 전용 속성을 부여했다.

5 - 12 : 클로저로 변수를 보호한 자동차 객체(2)
  코드는 5 - 11에서 5 ~ 20번째 줄까지를 publicMembers로써 객체 선언을 해주었다. 이렇게 함으로써 run메서드를 다른 내용으로 덮어씌우는 행동을 하지 못하도록 하였다. 클로저를 활용해 접근권한을 제어하는 방법으로는 첫째, 함수에서 지역변수 및 내부함수 등을 생성하는 것이고, 둘째로는 외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터를 return하게 한다. 이렇게하면 return한 변수들은 공개 멤버가 되고, 그렇지 않은 변수들은 비공개 멤버가 된다. 

5 - 13 : bind 메서드를 활용한 부분 적용 함수
  부분 적용 함수란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가, 후에 n - m개의 인자를 넘기면 원래 함수의 실행 결과를 얻을 수 있게끔 하는 함수이다. addPartial에 5개의 인자를 넘겨주었다가 후에 5개의 인자를 넘겨주도록함으로써 최종결과를 확인할 수 있다.

5 - 14 : 부분 적용 함수 구현(1)
  5 - 13에서의 문제점을 보완하기 위해 만들어진 코드이다. 5 - 13에서의 add함수는 this를 사용히지 않으므로 문제 없이 구현되었지만 this의 값을 변경하기 위해 새로 만들어졌다. 변수 addPartial의 함수에 partial에 첫번째 인자로 add함수를 넘겨주었다. 동작 방식은 5 - 13과 같다. 

5 - 15 : 부분 적용 함수 구현(2)
  5 - 14의 보완점인 부분 적용 함수에 넘길 인자를 반드시 앞에서부터 차례로 전달할 수 밖에 없는 것을 보완하기 위해 만들어진 코드이다. 동작 방식은 5 - 14와 같고 addPartial에 partial2함수에 불연속적으로 값을 넣고 후에 빈자리에 있는 값을 채워넣어 실행시켜 출력값을 확인할 수 있게 되었다.

5 - 16 : 부분 적용 함수 - 디바운스
  디바운스는 짧은 시간 동안 동일한 이벤트가 많이 발생할 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것으로, 프런트엔드 성능 최적화에 큰 도움을 주는 기능 중 하나이다.

5 - 17 : 커링 함수(1)
  커링 함수란 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 것. 한 번에 하나의 인자만을 전달하는 것을 원칙으로한다. 중간 과정상의 함수를 실행한 결과는 그다음 인자를 받기 위해 대기만 할 뿐, 마지막 인자가 전달되기 전까지는 원본 함수가 실행되지 않는다. 위 코드는 두 인자를 비교했을 때, 둘 중 어느 것이 최댓값인지 확인하고 반환하는 코드이다. 두 인자가 필요하므로 함수가 2개 만들어졌다.

5 - 18 : 커링 함수(2)
  5 - 17과 동작원리는 같다. 비교 인자가 5개로 많아졌다. 따라서 함수도 5개가 만들어졌다. 이를 편하게 작성하기위해 화살표 함수를 도입하였다. 마지막 호출로 실행 컨텍스트가 종료되면 한꺼번에 GC대상이 된다. 
  
# JS_CH5
